<x:document xmlns:x="http://local/" width="600"
            title="Noisy edges">

  <address>25 Aug 2017</address>

  <style>
      .v { fill: hsl(0,50%,50%); }
      .t { fill: hsl(240,50%,50%); }
      .c { fill: hsl(120,30%,50%); }
      .e { fill: none; stroke: hsl(0,0%,0%); stroke-width: 2px; }
      .b { fill: hsl(30,10%,80%); fill-opacity: 0.2; stroke: hsl(0,0%,75%); stroke-width: 2px; }
      input[type="range"] { cursor: ew-resize; }
      .cropimage { position: relative; height: 200px; overflow: hidden; }
      .cropimage img { position: relative; top: -100%; }
      .controls { margin: 0 100px; }
  </style>
  
  <x:section>

    <div id="vue-container">
      
      <p>
        In <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/#edges">map generator projects that generate polygons</a>, I often want to use the polygons for the structure of the map:
      </p>

      <div class="cropimage">
        <img src="blog/noisy-edges-amplitude-00.png"/>
      </div>

      <p>
        But I don't want the player to <em>see</em> polygons on the final map. I use "noisy edges" to hide the polygon structure:
      </p>

      <div class="cropimage">
        <img src="blog/noisy-edges-amplitude-25.png"/>
      </div>
      
      <p>
        On this page I'll show you how this works.
      </p>

      <p>
        I've been using a <a href="http://www.redblobgames.com/x/1721-voronoi-alternative/">mesh structure</a>. Red points <svg width="1em" height="1em" viewBox="-10 -10 20 20"><circle class="v" r="8"/></svg> are the <strong>interiors</strong> of the polygons. Blue points <svg width="1em" height="1em" viewBox="-10 -10 20 20"><circle class="t" r="8"/></svg> are the <strong>corners</strong> of the polygons.
      </p>

      <div class="cropimage">
        <img src="blog/single-mesh-50.png"/>
      </div>

      <p>
        In addition to the polygons and their duals (triangles, not shown), there's another structure that's useful. We can build quadrilaterals out of two red points and two blue points:
      </p>

      <div class="cropimage">
        <img src="blog/quadrilateral-subdivision.png"/>
      </div>
      
      <p>
        Let's look at one of these quadrilaterals more closely:
      </p>
      
      <svg width="600" height="300">
        <a-base :data="{t0, t1, v0, v1}"/>
      </svg>
      
      <p>
        We're interested in drawing a line between the two blue points:
      </p>

      <svg width="600" height="300">
        <path class="e" :d="`M ${t0} L ${t1}`" style="stroke-width: 4px"/>
        <a-base :data="{t0, t1, v0, v1}"/>
      </svg>

      <p>
        These lines are used for the polygon boundaries, which might be the borders between biomes, the coastlines, or rivers.
      </p>
      
      <p>
        We want to vary this line while keeping it inside the quadrilateral. We can use a variant of <em>midpoint displacement</em>. Pick a division point  <svg width="1em" height="1em" viewBox="-10 -10 20 20"><circle class="c" r="8"/></svg> between the red points. Use it to divide the line segment between the blue points into two shorter line segments:
      </p>

      <svg width="600" height="300">
        <path class="e" :d="`M ${t0} L ${center} L ${t1}`"/>
        <path class="b" :d="`M ${v0} L ${v1}`"/>
        <a-base :data="{t0, t1, v0, v1}"/>
        <a-circle class="c" :at="center"/>
      </svg>
      <div class="controls">
        division = <input type="range" min="0" max="1" step="0.01" v-model.number="division"/> {{ division }}
      </div>

      <p>
        Once we have picked a division point, it forms four smaller quadrilaterals. We'll use two of the quadrilaterals to further subdivide the line:
      </p>

      <svg width="600" height="300">
        <a-quad :a="t0" :b="center" :p="m00" :q="m01"/>
        <a-quad :a="center" :b="t1" :p="m10" :q="m11"/>
        <a-base :data="{t0, t1, v0, v1}"/>
        <a-circle class="c" :at="center"/>
      </svg>
      <div class="controls">
        division = <input type="range" min="0" max="1" step="0.01" v-model.number="division"/> {{ division }}
      </div>
      
      <p>
        We can repeat this process, recursively dividing the quadrilaterals, each time picking a random subdivision point that breaks a line segment into two shorter ones:
      </p>
      
      <svg width="600" height="300">
        <a-quad v-for="quad in quads"
                :a="quad.a" :b="quad.b" :p="quad.p" :q="quad.q"
                style="stroke-width: 1px; stroke-opacity: 0.5"/>
        <circle v-for="quad in quads"
                class="c" :cx="quad.a[0]" :cy="quad.a[1]" :r="1+quad.level"
                stroke="black" stroke-width="1" stroke-opacity="0.2" />
        <a-base :data="{t0, t1, v0, v1}"/>
      </svg>
      <div class="controls">
        levels = <input type="range" min="0" max="7" v-model.number="levels"/> {{ levels }}
        <br/><button v-on:click="nextSeed">generate another</button>
      </div>
      
      <p>
        This gives us a noisy line between the blue points, with two parameters to control how noisy it is:
      </p>

      <svg width="600" height="300">
        <a-quad v-for="quad in quads"
                :a="quad.a" :b="quad.b" :p="quad.p" :q="quad.q"
                style="stroke-width: 1px; stroke-opacity: 0.5"/>
        <path class="e" :d="path" style="stroke-width: 1px"/>
        <a-base :data="{t0, t1, v0, v1}"/>
      </svg>
      <div class="controls">
        subdivide into <input type="range" min="0" max="7" v-model.number="levels"/> 2<sup>{{ levels }}</sup> = {{ 1 &lt;&lt; levels }} segments
        <br/>amplitude = <input type="range" min="0.0" max="1.0" step="0.01" v-model.number="divisionSpan"/> {{ divisionSpan }}
        <br/><button v-on:click="nextSeed">generate another</button>
      </div>

      <p>
        I used a variant of this in my polygon map generator project in 2010 but never explained the technique in detail until now. In that project I picked the green division point along <em>both</em> axes instead of only the red point axis. I haven't explored that variant here. Making these diagrams made me realize my old code was not only buggy, but unnecessarily complicated. For this project I needed to pick a point only along one axis.
      </p>

      <p>
        An amplitude parameter of 0.5 seems pretty good in this demo but the best value will depend on your map and your needs; I ended up using 0.25 for my map generator, but I think an even lower value might be better. You can choose the number of levels by calculating when the line segments become too short to matter (a few pixels/tiles).
      </p>

      <p>
        There's something weird when going from 0 levels to 1 level. Try setting amplitude to 0 and levels to 0, then levels to 1. There's a bend in the line. But from 1 to 2 or more, theres's no change. That means that at all but the top level, the intersection of the red segment and blue segment occurs at the midpoint of the red segment, but at the top level it does not. That's something I still need to investigate. There may be some geometric properties that are useful for the map generator.
      </p>

      <p>
        I feel that the noisy edges from this algorithm can be a little too “sharp” but that's something to investigate later.
        For coastlines and rivers, noisy edges aren't the only option. I also want to look more closely at <a href="https://heredragonsabound.blogspot.com/2017/08/decorating-ocean-part-three.html">Scott Turner's blog</a> and <a href="https://azgaar.wordpress.com/2017/04/03/coastline/">Azgaar's blog</a>. For biome boundaries, I want to try noise-based dithering.
      </p>
      
    </div>
    
  </x:section>

  <x:footer>
    <script src="/js/prng.js"/>
    <script src="/js/vue.min.js"/>
    <script src="diagrams-noisy-edges.js"/>
    
    Created 25 Aug 2017 with Vue.js; &#160;
    <!-- hhmts start -->Last modified: 29 Aug 2017<!-- hhmts end -->
  </x:footer>
  
  
</x:document>

