#+title: Mapgen2, HTML5
#+date: <2017-08-03>

#+begin_export html
<x:draft/>

<style>
  figure { margin-left: 0; margin-right: 0; }
  .hover-term { cursor: help; border-bottom: 2px dashed black; }
  #diagram-mesh-construction button { background-color: hsl(60,10%,90%); }
  #diagram-mesh-construction button.active { background-color: hsl(120,50%,80%); border-color: hsl(120,50%,50%); }
</style>
#+end_export

WIP- recreating the diagrams and algorithms from http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/ in html5

#+begin_export html
<div style="clear:both"/>
#+end_export

* Polygons

There are four steps to constructing the polygon mesh we need:

#+begin_export html
<div id="diagram-mesh-construction">
  <figure>
    <figcaption>
      <span v-if="show==='points'">Evenly distributed points</span>
      <span v-else-if="show==='delaunay'">Delaunay triangulation</span>
      <span v-else-if="show==='centroids'">Triangle centroids</span>
      <span v-else-if="show==='polygons'">Polygons</span>
      <span v-else="">Dual mesh</span>
    </figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,centroidCircumcenterMix}"/>
  </figure>
  <ol>
    <li>Pick <span class="hover-term" v-on:mouseover="show='points'">evenly distributed points</span> using Poisson disc (or Lloyd relaxation).</li>
    <li>Construct a <span class="hover-term" v-on:mouseover="show='delaunay'">Delaunay triangulation</span>.</li>
    <li>Calculate the <span class="hover-term" v-on:mouseover="show='centroids'">centroids of the triangles</span>.</li>
    <li>Construct <span class="hover-term" v-on:mouseover="show='polygons'">polygons from those points</span>.</li>
  </ol>
  <p>
    Putting it all together, I have a <span class="hover-term" v-on:mouseover="show=null">dual mesh</span>. The same steps work for Voronoi instead of centroid polygons; compare: Centroid&nbsp;<input type="range" min="0" max="1" step="0.01" v-model.number="centroidCircumcenterMix"/>&nbsp;Voronoi.
  </p>
</div>
#+end_export

{ implementation notes - here or later? }

For evenly distributed red points, I used [[http://devmag.org.za/2009/05/03/poisson-disk-sampling/][Poisson disc sampling]] in this project and [[https://en.wikipedia.org/wiki/Lloyd%2527s_algorithm][Lloyd relaxation]] in a previous project. 

I added points along the boundary of the map with a slight curvature to avoid long skinny Delaunay triangles.

* Map representation

{ should implementation be on a separate page? }

[[http:/x/1722-b-rep-triangle-meshes/][stuff from this page]]

* Islands

I'm generating islands, so the boundary of the map will always be water. In the interior, I can use noise to determine which areas are land and water.

#+begin_export html
<div id="diagram-water-assignment">
  <figure>
    <figcaption v-if="show==='landwater'">Choose polygons that are water vs land</figcaption>
    <figcaption v-else-if="show==='lakes'">Lakes are water polygons not connected to the boundary</figcaption>
    <figcaption v-else="">Coastline separates oceans from land</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,show,v_water,v_ocean}"/>
    parameters: noisy<input type="range" min="0" max="1" step="0.01" v-model.number="round"/>round ;  
    deflate<input type="range" min="0" max="1" step="0.01" v-model.number="inflate"/>inflate
  </figure>
  <p>
    There are two things we need once we've assigned water vs land:
  </p>
  <ol>
    <li>Use noise to determine <span class="hover-term" v-on:mouseover="show='landwater'">land vs. water</span>.</li>
    <li>Use connectivity to mark <span class="hover-term" v-on:mouseover="show='lakes'">lakes</span> as the polygons not connected to the boundary of the map. <em v-if="counts.lake === 0">Try changing the parameters until lakes form.</em></li>
    <li>Define <span class="hover-term" v-on:mouseover="show=null">coastlines</span> to be edges connected to an ocean polygon on one side and a land polygon on the other.</li>
  </ol>
</div>
#+end_export

{ should I explain the game's needs, so that the reader can pick different algorithms that match their own needs? }

{ implementation notes could include the noise function -- maybe the noisy/deflate parameters could move to a separate diagram to avoid having to explain the lack of lakes in the main list; connectivity is depth first or breadth first search }

* Elevation

For this project I set elevation based on the /distance from the coast/. It's not the right choice for most maps, but it was the right thing for the project I made this for. To calculate it, I'll run Breadth First Search from the coastline. I tried distances on the polygons and distances on the corners, and I found corners worked better for this map generator. 

#+begin_export html
<div id="diagram-elevation-assignment">
  <figure>
    <figcaption v-if="show==='coast_t'">Coastline</figcaption>
    <figcaption v-else-if="show==='v_elevation'">Distance from coastline, corners</figcaption>
    <figcaption v-else="">Distance from coastline, polygons</figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,t_elevation,t_coastdistance,v_elevation}"/>
  </figure>
  <ol>
    <li>Find <span class="hover-term" v-on:mouseover="show='coast_t'">corners along coastline edges</span>. As above, coastline edges have an ocean on one side and land on the other side.</li>
    <li>Calculate corner <span class="hover-term" v-on:mouseover="show='t_coastdistance'">distance from the coastline</span> using Breadth First Search.</li>
    <li>Set <span class="hover-term" v-on:mouseover="show='t_elevation'">corner elevation</span> by rescaling ocean distances from -1 to 0 and land distances from 0 to +1.</li>
    <li>Set the <span class="hover-term" v-on:mouseover="show=null">polygon elevation</span> to the lowest elevation of the polygon's corners.</li>
  </ol>
</div>
#+end_export

{ implementation notes: . The average or max of the corners would work as well.  Rescale the elevations from 0.0 to 1.0. }


** TODO Handle lakes

** TODO Elevation from noise

Elevation based on distance to coastline produces simplistic symmetric volcanic-style islands. It's what we wanted in our game. There are lots of other ways to set elevation.

** TODO Controlling the distribution

If we have a desired distribution of elevations, we can reshape the distribution. I'm using a linear mapping from distance to elevation but that mapping can be anything.

* Rivers

At each corner, I can point to the corner that has the lowest elevation. This forms a drainage map, sometimes called a watershed map. Note that it follows some basic rules of rivers:

1. Rivers join together (tributaries) but don't fork (distributaries).
2. Rivers eventually reach the ocean.
3. There are no cycles.

The algorithm I'm using here produces poor results in the oceans. That's ok for now; I'm not using the values in the ocean in this project.

#+begin_export html
<div id="diagram-drainage-assignment">
  <figure>
    <figcaption>Drainage patterns</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,v_water,v_ocean,v_elevation,t_downslope_e,river_t,e_flow}"/>
  </figure>
  <button v-on:click="reset">Reset</button>
  <input type="range" min="0" :max="spring_t.length" v-model.number="numRivers"/> rivers
  <button v-on:click="addRiver">Add river</button>
  <button v-on:click="addRiver25">Add 25</button>
</div>
#+end_export

Drainage can be used for both watersheds and rivers, and both of those often form political boundaries. In this project I need rivers but not watersheds.

** TODO Lakes

** TODO Parameters for selecting a subset of rivers

Not all locations produce equally good rivers. Some filters to consider:

1. Only "leaves" of the drainage tree. (implemented above)
2. Only above some elevation threshold.
3. Only on sloped land. (if you have variable slopes)
4. Only locations with plenty of rainfall. (if you have rainfall implemented)
5. Only locations with wind carrying moisture from bodies of water.
6. Only land that's on a peak not a valley.

* Moisture

I use a “moisture” value to assign biomes in the next section. I set moisture to the /distance/ from a river. The start points are the polygons adjacent to a river; they will have distance 0. Similar to elevation, I use Breadth First Search to calculate the distances, then rescale them to a 0–1 range.

#+begin_export html
<div id="diagram-moisture-assignment">
  <figure>
    <figcaption>Moisture</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,v_water,v_ocean,v_moisture,t_downslope_e,river_t,e_flow}"/>
  </figure>
  <button v-on:click="reset">Reset</button>
  <input type="range" min="0" :max="spring_t.length" v-model.number="numRivers"/> rivers
  <button v-on:click="addRiver10">Add rivers</button>
</div>
#+end_export

If the river density is too low or too high the distribution isn't even.

There are many other ways to assign moisture/humidity/rainfall. I used this one because it was simple and worked well for the game these maps were for, but also consider using noise (Perlin, Simplex, etc.) or wind simulation (rain shadows, evapotranspiration, etc.).

** TODO Controlling the distribution

If we have a desired distribution of moisture, we can reshape the distribution. I'm using a sqrt mapping from distance to moisture but that mapping can be anything.

* Biomes

(explanation about whittaker diagrams)

#+begin_export html
<div id="diagram-biome-assignment">
  <figure>
    <figcaption>Biomes</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,river_t,e_flow,v_biome}"/>
  </figure>
  <button v-on:click="reset">Reset</button>
  <input type="range" min="0" :max="spring_t.length" v-model.number="numRivers"/> rivers
  <button v-on:click="addRiver10">Add rivers</button>
</div>
#+end_export

** TODO Controlling the distribution

See also http://worldengine-ecs.readthedocs.io/en/latest/biomes.html -- it seems useful to draw the scatter plot or a density plot, and then provide parameters for tuning that to make an ice world or a forest world etc.

* Noisy rendering

** Noisy edges

** Noisy transitions

** Noisy fills

* References


https://heredragonsabound.blogspot.com/

https://m.mythcreants.com/blog/crafting-plausible-maps/

http://www.giantitp.com/articles/xO3dVM8EDKJPlKxmVoG.html


* More

#+begin_export html
  <x:footer>
    <script src="/js/vue.js"/>
    <script src="/js/prng.js"/>
    <script src="_bundle.js"/>

    Created 3 Aug 2017 with <a href="https://vue.org/">Vue.js</a> and Emacs org-mode (<a href="index.org">source of this page</a>); &#160;
    <!-- hhmts start -->Last modified: 15 Aug 2017<!-- hhmts end -->
  </x:footer>
#+end_export
