#+title: Mapgen2, HTML5
#+date: <2017-08-03>

#+begin_export html
<x:draft/>

<style>
  figure { margin-left: 0; margin-right: 0; }
  .hover-term { cursor: help; border-bottom: 2px dashed black; }
  #diagram-mesh-construction button { background-color: hsl(60,10%,90%); }
  #diagram-mesh-construction button.active { background-color: hsl(120,50%,80%); border-color: hsl(120,50%,50%); }
</style>
#+end_export

WIP- recreating the diagrams and algorithms from http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/ in html5

* Polygons

There are four steps to constructing the polygon mesh we need:

#+begin_export html
<div id="diagram-mesh-construction">
  <ol>
    <li><button v-on:click="time_goal = 0" :class="time &lt; 0.9? 'active':null">Go</button> Pick some evenly distributed points.</li>
    <li><button v-on:click="time_goal = 1" :class="time &gt;= 0.9 &amp;&amp; time &lt; 1.9? 'active':null">Go</button> Construct the Delaunay triangulation.</li>
    <li><button v-on:click="time_goal = 2" :class="time &gt;= 1.9 &amp;&amp; time &lt; 2.9? 'active':null">Go</button> Calculate the triangle centroids.</li>
    <li><button v-on:click="time_goal = 3" :class="time &gt;= 2.9 ? 'active':null">Go</button> Construct polygons from the centroid points.</li>
  </ol>
  <figure>
    <canvas width="600" height="600" v-draw="{mesh,time,centroid_circumcenter_mix}"/>
    <figcaption>
      <span v-if="time &lt; 0.9">1. Pick points</span>
      <span v-else-if="time &lt; 1.9">2. Delaunay triangulation</span>
      <span v-else-if="time &lt; 2.9">3. Triangle centroids</span>
      <span v-else="">4. Polygons</span>
      <span v-if="time &gt;= 1.9">&nbsp;&nbsp;(compare: centroid <input type="range" min="0" max="1" step="0.01" v-model.number="centroid_circumcenter_mix"/> voronoi)</span>
    </figcaption>
  </figure>
</div>
#+end_export

For evenly distributed red points, I used [[http://devmag.org.za/2009/05/03/poisson-disk-sampling/][Poisson disc sampling]] in this project and [[https://en.wikipedia.org/wiki/Lloyd%2527s_algorithm][Lloyd relaxation]] in a previous project. I added points along the boundary of the map with a slight curvature to avoid long skinny Delaunay triangles. I originally used Voronoi polygons but to more evenly space the blue points, I switched to centroids.

* Map representation

* Islands

I'm generating islands, so the boundary of the map will always be water. In the interior, I can use noise to determine which areas are land and water.

#+begin_export html
<div id="diagram-water-assignment">
  <figure>
    <figcaption v-if="show_coast">Coastline separates oceans from land</figcaption>
    <figcaption v-else-if="show_lakes">Lakes are water polygons not connected to the boundary</figcaption>
    <figcaption v-else="">Choose polygons that are water vs land</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,v_water,v_ocean,show_lakes,show_coast}"/>
    parameters: noisy<input type="range" min="0" max="1" step="0.01" v-model.number="round"/>round ;  
    deflate<input type="range" min="0" max="1" step="0.01" v-model.number="inflate"/>inflate
  </figure>
  <p>
    There are two things we need once we've assigned water vs land:
  </p>
  <ol>
    <li><span class="hover-term" v-on:mouseover="show_lakes=true" v-on:mouseout="show_lakes=false">Lakes</span> are the polygons not connected to the boundary of the map. In this map there are {{counts.ocean}} oceans and {{counts.lake}} lakes. <em v-if="counts.lake === 0">Try changing the parameters until lakes form.</em></li>
    <li><span class="hover-term" v-on:mouseover="show_coast=true" v-on:mouseout="show_coast=false">Coastlines</span> are the edges connected to an ocean polygon on one side and a land polygon on the other.</li>
  </ol>
</div>
#+end_export

* Elevation

For this project I set elevation based on the /distance from the coast/. It's not the right choice for most maps, but it was the right thing for the project I made this for. To calculate it, I'll run Breadth First Search from the coastline. I tried distances on the polygons and distances on the corners, and I found corners worked better for this map generator. 

#+begin_export html
<div id="diagram-elevation-assignment">
  <figure>
    <figcaption v-if="show==='coast_t'">Coastline</figcaption>
    <figcaption v-else-if="show==='v_elevation'">Distance from coastline, corners</figcaption>
    <figcaption v-else="">Distance from coastline, polygons</figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,t_elevation,v_elevation}"/>
  </figure>
  
  <p>
    To find the start points for breadth first search, I picked <span class="hover-term" v-on:mouseover="show='coast_t'">corners along a coastline edge</span>. As above, coastline edges have an ocean on one side and land on the other side. Once I have <span class="hover-term" v-on:mouseover="show='v_elevation'">distance from the coastline</span> on corners, I need to convert it back to polygons. I chose to set the <span class="hover-term" v-on:mouseover="show=null">polygon elevation</span> to the <code>min()</code> of the corner elevations. The average or max would work as well.
  </p>
</div>
#+end_export

** TODO Handle lakes

** TODO Elevation from noise

** TODO Redistribution

* Rivers

At each corner, I can point to the corner that has the lowest elevation. This forms a drainage map, sometimes called a watershed map. Note that it follows some basic rules of rivers:

1. Rivers join together (tributaries) but don't fork (distributaries).
2. Rivers eventually reach the ocean.

The algorithm I'm using here produces poor results in the oceans. That's ok for now; I'm not using the values in the ocean in this project.

#+begin_export html
<div id="diagram-drainage-assignment">
  <figure>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,v_elevation,t_downslope_e}"/>
  </figure>
</div>
#+end_export

Drainage can be used for both watersheds and rivers, and both of those often form political boundaries. In this project I need rivers but not watersheds.

The important thing about drainage is that it has /no cycles/.

** TODO Lakes

** TODO Arrows

** TODO Mouse over a t-point to see the river

** TODO Parameters for selecting a subset of rivers

* Moisture

I use “moisture” to assign biomes in the next section. I set moisture to the /distance/ from a river. The start points are the polygons adjacent to a river; they will have distance 0.

* Biomes

* Noisy rendering

** Noisy edges

** Noisy transitions

** Noisy fills

* References

* More

#+begin_export html
  <x:footer>
    <script src="/js/vue.js"/>
    <script src="/js/prng.js"/>
    <script src="_bundle.js"/>

    Created 3 Aug 2017 with <a href="https://vue.org/">Vue.js</a> and Emacs org-mode (<a href="index.org">source of this page</a>); &#160;
    <!-- hhmts start -->Last modified: 09 Aug 2017<!-- hhmts end -->
  </x:footer>
#+end_export
