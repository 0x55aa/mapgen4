#+title: Mapgen2, HTML5
#+date: <2017-08-03>

#+begin_export html
<x:draft/>

<style>
  input[type="range"] { cursor: ew-resize; }
  figure { margin-left: 0; margin-right: 0; }
  .hover-term { cursor: help; border-bottom: 2px dashed black; }
  #diagram-mesh-construction button { background-color: hsl(60,10%,90%); }
  #diagram-mesh-construction button.active { background-color: hsl(120,50%,80%); border-color: hsl(120,50%,50%); }
</style>
#+end_export

WIP- recreating the diagrams and algorithms from http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/ in html5

#+begin_export html
<div style="clear:both"/>
#+end_export

General approach: based on the needs of the game, sketch out some possibilities and figure out the constraints of what must always happen and what must never happen. What remains is stuff that /could/ happen, and that's where I plug in randomness and noise.

For example if calculating the roll of a 6-sided die, I can say that a result of 5 or 2 is allowed but a result of 3.14 or -4 is not. From that, I would list the constraints: the output is an integer between 1 and 6 inclusive. What remains is that I didn't specify which integer between 1 and 6, or how often each one is chosen. I can use randomness to decide.

For map generation, this page documents a project from 2010 in which I looked at the needs of a game, [[http://www.metacritic.com/game/pc/realm-of-the-mad-god][Realm of the Mad God]], and designed a map generator specifically for its needs.

{why polygons?}

* Polygons

There are four steps to constructing the polygon mesh we need:

#+begin_export html
<div id="diagram-mesh-construction">
  <figure>
    <figcaption>Dual mesh construction</figcaption>
    <canvas width="600" height="600"/>
  </figure>
  <ol>
    <li>Pick <span class="hover-term" data-show="points">evenly distributed points</span> using Poisson disc (or Lloyd relaxation).</li>
    <li>Construct a <span class="hover-term" data-show="delaunay">Delaunay triangulation</span>.</li>
    <li>Calculate the <span class="hover-term" data-show="centroids">centroids of the triangles</span>.</li>
    <li>Construct <span class="hover-term" data-show="polygons">polygons from those points</span>.</li>
  </ol>
  <p>
  Putting it all together, I have a <span class="hover-term" data-show="all">dual mesh</span>. The same steps work for Voronoi instead of centroid polygons; compare: Centroid&nbsp;<input name="centroidCircumcenterMix" type="range" min="0" max="1" step="0.01"/>&nbsp;Voronoi.
  </p>
</div>
#+end_export

{ implementation notes - here or later? }

For evenly distributed red points, I used [[http://devmag.org.za/2009/05/03/poisson-disk-sampling/][Poisson disc sampling]] in this project and [[https://en.wikipedia.org/wiki/Lloyd%2527s_algorithm][Lloyd relaxation]] in a previous project. 

I added points along the boundary of the map with a slight curvature to avoid long skinny Delaunay triangles.

* Map representation

{ should implementation be on a separate page? }

[[http:/x/1722-b-rep-triangle-meshes/][stuff from this page]]

* Islands

I'm generating islands, so the boundary of the map will always be water. In the interior, I can use noise to determine which areas are land and water. {this is the constraint+randomness theme}

#+begin_export html
<div id="diagram-water-assignment">
  <figure>
    <figcaption>Water, ocean, lake, coastlines</figcaption>
    <canvas width="600" height="600"/>
    parameters: noisy<input name="round" type="range" min="0" max="1" step="0.01"/>round ;  
    deflate<input name="inflate" type="range" min="0" max="1" step="0.01"/>inflate
  </figure>
  <p>
    There are two things we need once we've assigned water vs land:
  </p>
  <ol>
    <li>Use noise to determine <span class="hover-term" data-show="landwater">land vs. water</span>.</li>
    <li>Use <span class="hover-term" data-show="connectivity">connectivity</span> to determine which water polygons are ocean.</li>
    <li><span class="hover-term" data-show="lakes">Lakes</span> are the water polygons not connected to the boundary of the map.</li>
    <li><span class="hover-term" data-show="all">Coastlines</span> are the edges connected to an ocean polygon on one side and a land polygon on the other.</li>
  </ol>
</div>
#+end_export

{ should I explain the game's needs, so that the reader can pick different algorithms that match their own needs? }

{ implementation notes could include the noise function -- maybe the noisy/deflate parameters could move to a separate diagram to avoid having to explain the lack of lakes in the main list; connectivity is depth first or breadth first search }

** TODO Noise map

- Display the noise values and the land/water map side by side
- Control noisy/deflate parameters here
- Control octaves/etc parameters here

** TODO Lakes

- Highlight some lakes on the map using my svg arrow-out-of-the-box; it doesn't have to be a separate diagram

* Elevation

For this project I set elevation based on the /distance from the coast/. It's not the right choice for most maps, but it was the right thing for the project I made this for. To calculate it, I'll run Breadth First Search from the coastline. I tried distances on the polygons and distances on the corners, and I found corners worked better for this map generator. 

#+begin_export html
<div id="diagram-elevation-assignment">
  <figure>
    <figcaption>Elevation</figcaption>
    <canvas width="600" height="600"/>
  </figure>
  <ol>
    <li>Find <span class="hover-term" data-show="coast_t">corners along coastline edges</span>. As above, coastline edges have an ocean on one side and land on the other side.</li>
    <li>Calculate corner <span class="hover-term" data-show="t_coastdistance">distance from the coastline</span> using Breadth First Search.</li>
    <li>Set <span class="hover-term" data-show="t_elevation">corner elevation</span> by rescaling ocean distances from -1 to 0 and land distances from 0 to +1.</li>
    <li>Set the <span class="hover-term" data-show="all">polygon elevation</span> to the average elevation of the polygon's corners.</li>
  </ol>
</div>
#+end_export

{distance from coast is a constraint; there's no randomness here}

** Lakes

If there are no lakes, Breadth First Search works great, but with lakes, things get more complicated. I want the entire lake to have the same corner elevation, so I check if the edge has a lake on either side. If so, I don't increase the distance along that edge. Look at the distance visualization to see this around lakes. This turns breadth first search into a more complicated graph search. I'm not happy with this but it's good enough for now.

** TODO Elevation from noise

Elevation based on distance to coastline produces simplistic symmetric volcanic-style islands. It's what we wanted in our game. There are lots of other ways to set elevation.

** TODO Controlling the distribution

{ show the distribution }

If we have a desired distribution of elevations, we can reshape the distribution. I'm using a linear mapping from distance to elevation but that mapping can be anything.

* Drainage

At each corner, I point to the corner that has the lowest elevation. This forms a drainage map, sometimes called a watershed map.

1. Streams start on land and flow down to the coastline.
1. Streams join together (tributaries) but don't fork (distributaries).
1. There are no cycles.

#+begin_export html
<div id="diagram-drainage-assignment">
  <figure>
    <figcaption>Drainage patterns</figcaption>
    <canvas width="600" height="600"/>
  </figure>
  <p>
    Because elevations are based on distances, there are <em>many</em>
    possible drainage graphs for the same elevation map. Which one we
    calculate depends on the graph traversal order. This is an opportunity
    to use a random seed to choose which of the many drainage graphs
    we generate:
    <button name="changeDrainageSeed">Change random seed</button>
  </p>
</div>
#+end_export

** Lakes

Along lakes, the elevation isn't increasing, so what should the drainage map do? I make the drainage map follow the graph search used for elevation, so any drainage leading into a lake will eventually lead out, but may take a convoluted path inside the lake. I'm not happy with this but it's good enough for now.

** TODO Watersheds

Drainage can also be used to define watersheds, which can be useful as political and cultural boundaries. Rivers are also useful as political (but not cultural) boundaries.

{ diagram or layer showing watershed boundaries }


* Rivers

Rivers are a subset of the streams in the drainage map.

1. Choose a subset of points to be potential river sources. {constraint}
2. Choose a subset of those points to be rivers. {random}

#+begin_export html
<div id="diagram-rivers">
  <figure>
    <figcaption>River creation</figcaption>
    <canvas width="600" height="600"/>
  </figure>
  <button name="reset">Reset</button>
  <input name="numRivers" type="range" min="0" max="1"/> rivers
  <button name="addRivers">Add rivers</button>
  <button name="changeRiverSeed">Change random subset</button>
</div>
#+end_export


** TODO Parameters for selecting a subset of rivers

Not all locations produce equally good rivers. Some filters to consider:

1. Only "leaves" of the drainage tree. (implemented above)
2. Only above some elevation threshold.
3. Only on sloped land. (if you have variable slopes)
4. Only locations with plenty of rainfall. (if you have rainfall implemented)
5. Only locations with wind carrying moisture from bodies of water.
6. Only land that's on a peak not a valley.

{should this be an interactive diagram?}

* Moisture

I use a “moisture” value to assign biomes in the next section. I set moisture on land to the /distance/ from a lakeshore or riverbank. The start points are polygons adjacent to lakes or rivers. Similar to elevation, I use Breadth First Search to calculate the distances, then rescale them. Zero distance will have moisture 1.0 and high distance will have moisture 0.0. Water polygons will have moisture 1.0.

#+begin_export html
<div id="diagram-moisture-assignment">
  <figure>
    <figcaption>Moisture</figcaption>
    <canvas width="600" height="600"/>
  </figure>
  <button name="reset">Reset</button>
  <input name="numRivers" type="range" min="0" max="0"/> rivers
  <button name="addRivers">Add rivers</button>
</div>
#+end_export

There are many other ways to assign moisture/humidity/rainfall. I used this one because it was simple and worked well for the game these maps were for. It's unable to produce effects like the Nile going through a desert. Other ways to assign moisture include noise (Perlin, Simplex, etc.) and wind simulation (rain shadows, evapotranspiration, etc.).

** TODO Controlling the distribution

{ show the distribution }

If we have a desired distribution of moisture, we can reshape the distribution. I'm using a sqrt mapping from distance to moisture but that mapping can be anything.

* Biomes

(explanation about whittaker diagrams, indexed with temperature and rainfall -- temperature is based on elevation and latitude, but on a small island the latitude is constant; rainfall is based on evaporation and wind but I'm just using moisture=evaporation here)

#+begin_export html
<div id="diagram-biome-assignment">
  <figure>
    <figcaption>Biomes</figcaption>
    <canvas width="600" height="600"/>
  </figure>
  <button name="reset">Reset</button>
  <input name="numRivers" type="range" min="0" :max="spring_t.length"/> rivers
  <button name="addRivers">Add rivers</button>
</div>
#+end_export

** TODO Noisy boundaries

1. Add random number to elevation/moisture
2. Add random noise to elevation/moisture

** TODO Controlling the distribution

{ show the distribution }

See also http://worldengine-ecs.readthedocs.io/en/latest/biomes.html -- it seems useful to draw the scatter plot or a density plot, and then provide parameters for tuning that to make an ice world or a forest world etc.

* Export

#+begin_export html
<div id="map-export">
  <textarea placeholder="JSON output here"
            style="width: 100%; height: 10em; border: 3px solid #ccc; padding: 5px; font-family: monospace; overflow: scroll" 
            onclick="this.setSelectionRange(0, this.value.length)"/>
  <button name="export">Export</button>
</div>
#+end_export


* Noisy rendering

** Noisy edges

** Noisy transitions

** Noisy fills

* References


https://heredragonsabound.blogspot.com/

https://m.mythcreants.com/blog/crafting-plausible-maps/

http://www.giantitp.com/articles/xO3dVM8EDKJPlKxmVoG.html


* More

#+begin_export html
  <x:footer>
    <script src="/js/prng.js"/>
    <script src="_bundle.js"/>

    Created 3 Aug 2017 with Emacs org-mode (<a href="index.org">source of this page</a>); &#160;
    <!-- hhmts start -->Last modified: 22 Aug 2017<!-- hhmts end -->
  </x:footer>
#+end_export
